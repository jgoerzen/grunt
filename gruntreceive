#!/usr/bin/env python2.2
# Startup from single-user installation
# Copyright (C) 2002 John Goerzen
# <jgoerzen@complete.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import sys, re, os, pwd, time, base64, md5, fcntl
from sys import stdin, stdout
import pyme, pyme.core
import GnuPGInterface

"""File format:

Plain:
:GRUNT:INSECUREHEADER:FORMAT-1I:
:USER:username
:DATA:

Signed/Encrypted:
:GRUNT:SECUREHEADER:FORMAT-1S:
:USER:username
:SENDER:senderstr
:RANDOM:randomstr
:MODE:mode
:DEST:destination
:DATA:
--data follows here--

*DATA MUST OCCUR IN THIS ORDER, NO UNSPECIFIED WHITESPACE PERMITTED*

Where:

  "username" is the name of the user to run as
  "mode" is one of:
     EXEC -- execute a command -- attached data to be used as stdin
     PUT  -- copy a file into place
  "destination" is:
     a filename (for PUT mode)
     a command (for EXEC mode)
  "senderstr" is:
     username:pid:time    time is seconds since epoch and must not have fractional part.
  "randomstr" is a base64-encoded random string and is ignored
  by the receiver.

All replaceable data (the lowercase stuff) must be base64-encoded.

No line, post-base64ing, may exceed 1023 characters.

     """

def copy(infile, outfile):
    while 1:
        data = infile.read(10240)
        if not len(data):
            return
        outfile.write(data)
    

# Start processing.

assert stdin.readline(1024).strip() == ':GRUNT:INSECUREHEADER:FORMAT-1I:'
username = re.search('^:USER:(.+)$', stdin.readline(1024).strip()).group(1)
username = base64.decodestring(username)
if pwd.getpwuid(os.getuid())[0] != username:
    destuid, destgid = pwd.getpwnam(username)[2:4]
    os.setgroups([])
    os.setregid(destgid, destgid)
    os.setreuid(destuid, destuid)
    
assert pwd.getpwuid(os.getuid())[0] == username,\
       "Could not change to correct user"

USERHOME = pwd.getpwuid(os.getuid())[5]
HOMEDIR = USERHOME + '/.grunt'
WORKDIR = HOMEDIR + '/work'
assert os.path.isfile(HOMEDIR + '/validsigs.txt'),\
       "File %s does not exist" % (HOMEDIR + '/validsigs.txt')
os.chdir(USERHOME)
os.environ['HOME'] = USERHOME
os.environ['LOGNAME'] = username
os.environ['USER'] = username

if not os.path.isdir(WORKDIR):
    os.mkdir(WORKDIR, 0700)

tmpfilename = WORKDIR + '/workfile-%d-%s' % (os.getpid(), time.time())
gnupg = GnuPGInterface.GnuPG()
gnupg.options.meta_interactive = 0
gnupg.options.quiet = 1
gnupg.options.no_verbose = 1
gnupg.options.no_greeting = 1
process = gnupg.run(['--decrypt', '--output', tmpfilename],
                    create_fhs=['status', 'stdin'])
if (os.fork() == 0):
    # Copy process.
    copy(stdin, process.handles['stdin'])
    stdin.close()
    process.handles['stdin'].close()
    process.handles['status'].close()
    sys.exit(0)
else:
    stdin.close()
    process.handles['stdin'].close()
goodsig = None
signatory = None
while 1:
    status = process.handles['status'].readline()
    if len(status) == 0:
        break
    statuswords = status.strip().split(' ')
    if statuswords[1] == 'GOODSIG':
        goodsig = 1
        signatory = statuswords[2]
    if statuswords[1] == 'BADSIG':
        goodsig = 0
process.wait()        
if not goodsig:
    try:
        os.unlink(tmpfilename)
    except OSError:
        pass
    raise ValueError, "FAILURE: no signature detected!"

# Now, check to see if this signature is in the user's list of acceptable ones.

shortsignatory = signatory[-8:]
foundvalid = 0

gsf = open(HOMEDIR + '/validsigs.txt')
for line in gsf.readlines():
    if line.strip() == shortsignatory or line.strip() == signatory:
        foundvalid = 1
        break
gsf.close()

if not foundvalid:
    try:
        os.unlink(tmpfilename)
    except OSError:
        pass
    raise ValueError, "FAILURE: Key %s (%s) not found in list of valid keys."%\
          (signatory, shortsignatory)

##################### PAST HERE, the sig is good.




datafile = open(tmpfilename)
try:
    #### Compute the md5 and see if we already have it.
    thismd5 = md5.md5()
    while 1:
        chunk = datafile.read(10240)
        if not len(chunk):
            break
        thismd5.update(chunk)
    datafile.seek(0, 0)

    thismd5 = thismd5.hexdigest()

    existingmd5s = []
    maxmd5age = 60L # days

    efd_low = os.open(HOMEDIR + '/seenmd5s.txt', os.O_RDWR | os.O_CREAT)
    fcntl.flock(efd_low, fcntl.LOCK_EX)
    efd = os.fdopen(efd_low, 'r+')
    firstline = efd.readline()
    if len(firstline):
        maxmd5age = long(firstline.strip())
        for line in efd.xreadlines():
            recordedmd5, dateepoch, datestr = line.strip().split(':')
            assert not recordedmd5 == thismd5,\
                   "ERROR: Detected attempt to resubmit existing request. DENIED."
            existingmd5s.append({'md5': recordedmd5,
                                 'dateepoch': long(dateepoch),
                                 'datestr': datestr})

    existingmd5s.append({'md5': thismd5,
                         'dateepoch': long(time.time()),
                         'datestr': time.asctime()})

    efd.seek(0, 0)

    efd.write("%d\n" % maxmd5age)
    now = long(time.time())
    multiplier = long(60 * 60 * 24)           # seconds in a day
    for entry in existingmd5s:
        if (now - entry['dateepoch']) < (maxmd5age * multiplier):
            efd.write("%s:%d:%s\n" % (entry['md5'], entry['dateepoch'], entry['datestr']))
    efd.flush()
    efd.close()

    # Good sig AND new request.  Process the data.

    assert datafile.readline(1024).strip() == ':GRUNT:SECUREHEADER:FORMAT-1S:'
    susername = re.search('^:USER:(.+)$', datafile.readline(1024).strip()).group(1)
    susername = base64.decodestring(susername)
    assert susername == username, 'FAILURE: secure packet username %s differs from regular username %s' % (susername, username)

    senderstr = re.search('^:SENDER:(.+)$', datafile.readline(1024).strip()).group(1)
    senderstr = base64.decodestring(senderstr)

    senderusername, senderpid, sendertime = senderstr.split(':')
    assert (now - long(sendertime)) < (maxmd5age * multiplier),\
           "Request submitted more than configured max age of %d days ago.  REJECTED." % maxmd5age

    assert datafile.readline(1024).strip().startswith(':RANDOM:')
    
    mode = re.search('^:MODE:(.+)$', datafile.readline(1024).strip()).group(1)
    mode = base64.decodestring(mode)
    
    dest = re.search('^:DEST:(.+)$', datafile.readline(1024).strip()).group(1)
    dest = base64.decodestring(dest)

    assert datafile.readline(1024).strip() == ':DATA:'

    if mode == 'EXEC':
        outputfd = os.popen(dest, 'w')
    elif mode == 'PUT':
        outputfd = open(dest + '.gruntput', 'wb')
    copy(datafile, outputfd)
    if mode == 'EXEC':
        sys.exit(not outputfd.close() == None)
    if mode == 'PUT':
        outputfd.close()
        os.rename(dest + '.gruntput', dest)
finally:
    datafile.close()
    os.unlink(tmpfilename)
